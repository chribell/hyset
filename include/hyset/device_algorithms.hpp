#pragma once

#ifndef HYSET_DEVICE_ALGORITHMS_HPP
#define HYSET_DEVICE_ALGORITHMS_HPP


#include <hyset/helpers.hpp>
#include <hyset/structs.hpp>
#include <hyset/containers.hpp>
#include <hyset/verification.hpp>
#include <hyset/output.hpp>


namespace hyset{
    namespace algorithms {
        namespace device {

            typedef std::pair<hyset::structs::block*, std::vector<hyset::structs::block*>> filter_pair;
            typedef std::map<hyset::structs::block*, std::vector<hyset::structs::block*>> filtered_map;

            template <typename Similarity>
            filtered_map length_filter(hyset::structs::partition* first,
                                       hyset::structs::partition* second,
                                       std::shared_ptr<hyset::collection::host_collection>& hostCollection, double threshold) {

                filtered_map filteredMap;

                std::vector<hyset::structs::block*>::const_iterator firstBlock;
                std::vector<hyset::structs::block*>::const_iterator secondBlock;

                for (firstBlock = first->blocks.begin(); firstBlock != first->blocks.end(); ++firstBlock) {

                    unsigned int indexedID = (*firstBlock)->id;

                    for (secondBlock = second->blocks.begin(); secondBlock != second->blocks.end(); ++secondBlock) {

                        unsigned int probeID = (*secondBlock)->id;

                        if (probeID < indexedID) continue; // this should only apply in case of self join (one input collection)

                        unsigned int lastIndexedSize    = hostCollection->sizes[(*firstBlock)->endID];
                        unsigned int firstProbeSize     = hostCollection->sizes[(*secondBlock)->startID];

                        if ( lastIndexedSize >= Similarity::minsize(firstProbeSize, threshold)) {
                            if (filteredMap.count(*firstBlock) == 0) {
                                filteredMap.insert(filter_pair(*firstBlock, {}));
                            }
                            filteredMap[*firstBlock].push_back(*secondBlock);
                        }
                    }
                }
                return filteredMap;
            }


            namespace bitmap {

                __global__ void generate(hyset::collection::device_collection_wrapper collection,
                                         hyset::containers::device_bitmap_wrapper bitmaps)
                {
                    unsigned int globalID = blockIdx.x * blockDim.x + threadIdx.x;

                    // iterate collection sets, each bitmap is generated by a unique thread
                    for (unsigned int setID = globalID; setID < collection.sizesLen; setID += blockDim.x * gridDim.x) {

                        unsigned int setStart = collection.starts[setID];
                        unsigned int setEnd = setStart + collection.sizes[setID];

                        for (unsigned int token = setStart; token < setEnd; ++token) {
                            // hash function => h(t) = t % b, (t: token b: bitmapSize)
                            change_bit(bitmaps.at(setID), collection.tokens[token] % bitmaps.bitmapSize, bitmaps.bitmapWords);
                        }
                    }
                }

                template <typename Similarity>
                __global__ void filter(hyset::collection::device_collection_wrapper collection,
                                       hyset::containers::device_bitmap_wrapper bitmaps,
                                       hyset::structs::block leftBlock,
                                       hyset::structs::block rightBlock,
                                       unsigned int* filter,
                                       unsigned int blockSize,
                                       double threshold) {

                    // starting right set
                    unsigned int startID = (blockIdx.x * blockDim.x + threadIdx.x) + rightBlock.startID;

                    // for every right set
                    for (unsigned int rightID = startID; rightID <= rightBlock.endID; rightID += blockDim.x * gridDim.x) {

                        unsigned int rightSetSize = collection.sizes[rightID];

                        unsigned int normalizedRightID = rightID - rightBlock.id * blockSize;
                        unsigned int minsize = Similarity::minsize(rightSetSize, threshold);
                        word* rightBitmap = bitmaps.at(rightID);

                        for (unsigned int leftID = leftBlock.startID; leftID <= leftBlock.endID; ++leftID) {
                            unsigned int leftSetSize = collection.sizes[leftID];

                            if (rightID > leftID && leftSetSize >= minsize) {
                                unsigned int normalizedLeftID = leftID - leftBlock.id * blockSize;
                                word* leftBitmap = bitmaps.at(leftID);

                                unsigned int popcount = hyset::hamming_distance(rightBitmap, leftBitmap,
                                                                                 bitmaps.bitmapWords);

                                unsigned int minoverlap = Similarity::minoverlap(rightSetSize, leftSetSize,
                                                                                 threshold);
                                double upperbound = (rightSetSize + leftSetSize - popcount) / 2.0;

                                unsigned int index = normalizedRightID * blockSize + normalizedLeftID;
                                if (upperbound >= minoverlap) {
                                    filter[index] = 1;
                                }
                            }
                        }
                    }
                }

                struct handler {
                    unsigned int bitmapSize;
                    unsigned int blockSize;
                    bool aggregate;
                    double threshold;

                    std::shared_ptr<hyset::timer::device> timer;

                    hyset::containers::device_array<unsigned int>* filter;
                    hyset::containers::device_result<unsigned int>* counts;
                    hyset::containers::device_result<hyset::structs::pair>* pairs;
                    std::shared_ptr<hyset::collection::host_collection> hostCollection;
                    hyset::collection::device_collection_wrapper collection;
                    hyset::containers::device_bitmaps* bitmaps;
                    std::shared_ptr<hyset::output::handler> output;

                    cuda::memory::managed::unique_ptr<unsigned int> count;

                    handler(std::shared_ptr<hyset::timer::device>& timer,
                            std::shared_ptr<hyset::collection::host_collection>& hostCollection,
                            hyset::collection::device_collection& inputCollection,
                            unsigned int bitmapSize, unsigned int blockSize, bool aggregate, double threshold) :
                            timer(timer), hostCollection(hostCollection), collection(inputCollection), bitmapSize(bitmapSize),
                            blockSize(blockSize), aggregate(aggregate), threshold(threshold) {
                        bitmaps = new hyset::containers::device_bitmaps(collection.sizesLen, BITMAP_NWORDS(bitmapSize));

                        auto current_device = cuda::device::current::get();
                        int gridX = current_device.get_attribute(cudaDevAttrMultiProcessorCount) * 16;
                        int threadsX = current_device.get_attribute(cudaDevAttrMaxThreadsPerBlock) / 2;

                        hyset::timer::device::EventPair* generateBitmaps =  timer->add("Generate Bitmaps", 0);

                        cuda::launch(hyset::algorithms::device::bitmap::generate,
                                     cuda::launch_configuration_t(gridX, threadsX, cuda::no_shared_memory),
                                     collection, *bitmaps);

                        timer->finish(generateBitmaps);

                        filter = new hyset::containers::device_array<unsigned int>(blockSize * blockSize);


                        hyset::timer::device::EventPair* allocateMemory =  timer->add("Allocate filter & output", 0);
                        if (aggregate) {
                            counts = new hyset::containers::device_result<unsigned int>(gridX);
                        } else {
                            pairs = new hyset::containers::device_result<hyset::structs::pair>(blockSize * blockSize);
                        }

                        count = cuda::memory::managed::make_unique<unsigned int>();
                        cuda::memory::zero(count.get(), sizeof(unsigned int));
                        timer->finish(allocateMemory);
                    }

                    inline void setOutputHandler(std::shared_ptr<hyset::output::handler>& outputHandler) {
                        output = outputHandler;
                    }

                    inline void join(hyset::structs::block* first, hyset::structs::block* second) {
                        auto current_device = cuda::device::current::get();
                        int gridX = current_device.get_attribute(cudaDevAttrMultiProcessorCount) * 16;
                        int threadsX = current_device.get_attribute(cudaDevAttrMaxThreadsPerBlock) / 2;


                        hyset::timer::device::EventPair* filterTime =  timer->add("Filter", 0);
                        // call bitmap filter
                        cuda::launch(hyset::algorithms::device::bitmap::filter<jaccard>,
                                     cuda::launch_configuration_t(gridX, threadsX, cuda::no_shared_memory),
                                     collection, *bitmaps, *first, *second, filter->ptr.get(), blockSize, threshold
                        );
                        timer->finish(filterTime);

                        hyset::timer::device::EventPair* verifyTime =  timer->add("Verify", 0);
                        // verify pairs
                        if (aggregate) {
                            cuda::launch(hyset::verification::device::verify_pairs<jaccard, true, false>,
                                         cuda::launch_configuration_t(gridX, threadsX, gridX * sizeof(unsigned int)),
                                         collection, collection, *counts, *first, *second, filter->ptr.get(), blockSize, count.get(), threshold
                            );


                            thrust::device_ptr<unsigned int> thrustCount(counts->output->ptr.get());
                            unsigned long result = thrust::reduce(thrust::device, thrustCount, thrustCount + gridX);
                            auto* countHandler = (hyset::output::count_handler*) output.get();
                            countHandler->count += result;
                        } else {

                            cuda::launch(hyset::verification::device::verify_pairs<jaccard, false, false>,
                                         cuda::launch_configuration_t(gridX, threadsX, cuda::no_shared_memory),
                                         collection, collection, *pairs, *first, *second, filter->ptr.get(), blockSize, count.get(), threshold
                            );

                            // copy counter to main memory
                            std::unique_ptr<unsigned int> globalCount = std::unique_ptr<unsigned int>(new unsigned int);
                            cuda::memory::copy(globalCount.get(), count.get(), sizeof(unsigned int));

                            auto* pairsHandler = (hyset::output::pairs_handler*) output.get();
                            std::vector<hyset::structs::pair> tmp;
                            tmp.resize(*globalCount);
                            cuda::memory::copy(&tmp[0], pairs->output->ptr.get(), sizeof(hyset::structs::pair) * (*globalCount));
                            pairsHandler->pairs.insert(std::end(pairsHandler->pairs), std::begin(tmp), std::end(tmp));
                            cuda::memory::zero(count.get(), sizeof(unsigned int));
                        }
                        timer->finish(verifyTime);

                        hyset::timer::device::EventPair* emptyFilter =  timer->add("Clear filter space", 0);
                        // empty device memory for next join
                        cuda::memory::zero(filter->ptr.get(), sizeof(unsigned int) * filter->length);
                        timer->finish(emptyFilter);

                    }


                    inline void join(hyset::structs::partition* first, hyset::structs::partition* second) {

                        // first apply length filter on block level
                        filtered_map joins = hyset::algorithms::device::length_filter<jaccard>(first, second, hostCollection, threshold);
                        filtered_map::iterator leftIterator = joins.begin();
                        while (leftIterator != joins.end()) { // process each join
                            hyset::structs::block* left = leftIterator->first;
                            std::vector<hyset::structs::block*>::iterator rightIterator;
                            for (rightIterator = leftIterator->second.begin(); rightIterator != leftIterator->second.end(); ++rightIterator) {
                                join(left, *rightIterator);
                            }

                            leftIterator++;
                        }

                    }

                    ~handler() {
                        hyset::timer::device::EventPair* freeTime =  timer->add("Free memory", 0);
                        bitmaps->hyset::containers::device_bitmaps::~device_bitmaps();
                        filter->hyset::containers::device_array<unsigned int>::~device_array();
                        if (aggregate) {
                            counts->hyset::containers::device_result<unsigned int>::~device_result();
                        } else {
                            pairs->hyset::containers::device_result<hyset::structs::pair>::~device_result();
                        }
                        timer->finish(freeTime);
                    }
                };
            }

            namespace fgssjoin {

                template <typename Similarity>
                __global__ void prefix_filter(hyset::collection::device_collection_wrapper indexedCollection,
                                              hyset::collection::device_collection_wrapper probeCollection,
                                              hyset::index::device_index_wrapper invertedIndex,
                                              hyset::structs::block indexedBlock,
                                              hyset::structs::block probeBlock,
                                              unsigned int* filter,
                                              unsigned int blockSize,
                                              double threshold)
                {


                    for (unsigned int i = blockIdx.x; i < probeBlock.size; i += gridDim.x) {

                        unsigned int probeID = i + probeBlock.startID;
                        unsigned int probeStart = probeCollection.starts[probeID];
                        unsigned int probeSize = probeCollection.sizes[probeID];

                        unsigned int minsize = Similarity::minsize(probeSize, threshold);
                        unsigned int maxprefix = Similarity::maxprefix(probeSize, threshold);

                        for (unsigned int j = 0; j < maxprefix; j++) {

                            unsigned int probeToken = indexedCollection.tokens[probeStart + j];
                            unsigned int listSize = invertedIndex.list_size(probeToken);
                            unsigned int listEnd = invertedIndex.list_end(probeToken);
                            unsigned int listStart = listEnd - listSize;

                            for (unsigned int k = listStart + threadIdx.x; k < listEnd; k += blockDim.x) {

                                unsigned int indexedID = invertedIndex.index[k].setID;

                                if (probeID > indexedID && probeCollection.sizes[indexedID] >= minsize) {
                                    atomicAdd(&filter[i * blockSize + indexedID - indexedBlock.startID], 1);
                                }
                            }
                        }
                    }
                }

                struct handler {
                    unsigned int blockSize;
                    bool aggregate;
                    double threshold;

                    std::shared_ptr<hyset::timer::device> timer;

                    hyset::containers::device_array<unsigned int>* filter;
                    hyset::containers::device_result<unsigned int>* counts;
                    hyset::containers::device_result<hyset::structs::pair>* pairs;
                    std::shared_ptr<hyset::collection::host_collection> hostCollection;
                    hyset::collection::device_collection_wrapper collection;
                    hyset::index::device_index* index;
                    std::shared_ptr<hyset::output::handler> output;

                    cuda::memory::managed::unique_ptr<unsigned int> count;

                    handler(std::shared_ptr<hyset::timer::device>& timer,
                            std::shared_ptr<hyset::collection::host_collection>& hostCollection,
                            hyset::collection::device_collection& deviceCollection, unsigned int blockSize, bool aggregate, double threshold) :
                            timer(timer), hostCollection(hostCollection), collection(deviceCollection),
                            blockSize(blockSize), aggregate(aggregate), threshold(threshold) {

                        auto current_device = cuda::device::current::get();
                        int gridX = current_device.get_attribute(cudaDevAttrMultiProcessorCount) * 16;

                        hyset::timer::device::EventPair* allocateIndex =  timer->add("Allocate inverted index", 0);
                        index = new hyset::index::device_index(hostCollection->universeSize, hostCollection->maxEntries);
                        timer->finish(allocateIndex);

                        hyset::timer::device::EventPair* allocateMemory =  timer->add("Allocate filter & output", 0);

                        filter = new hyset::containers::device_array<unsigned int>(blockSize * blockSize);

                        if (aggregate) {
                            counts = new hyset::containers::device_result<unsigned int>(gridX);
                        } else {
                            pairs = new hyset::containers::device_result<hyset::structs::pair>(blockSize * blockSize);
                        }

                        count = cuda::memory::managed::make_unique<unsigned int>();
                        cuda::memory::zero(count.get(), sizeof(unsigned int));
                        timer->finish(allocateMemory);
                    }

                    inline void setOutputHandler(std::shared_ptr<hyset::output::handler>& outputHandler) {
                        output = outputHandler;
                    }

                    inline void transferIndex(hyset::index::host_array_index* hostIndex) const {
                        hyset::timer::device::EventPair* copyIndex =  timer->add("Copy inverted index", 0);
                        index->index->length = hostIndex->index->length;
                        cuda::memory::copy(index->index->ptr.get(), hostIndex->index->ptr.get(), sizeof(hyset::structs::entry) * index->index->length);
                        index->offsets->length = hostIndex->offsets->length;
                        cuda::memory::copy(index->offsets->ptr.get(), hostIndex->offsets->ptr.get(), sizeof(unsigned int) * index->offsets->length);
                        timer->finish(copyIndex);
                    }

                    inline void join(hyset::structs::block* first, hyset::structs::block* second) {
                        auto current_device = cuda::device::current::get();
                        int gridX = current_device.get_attribute(cudaDevAttrMultiProcessorCount) * 16;
                        int threadsX = current_device.get_attribute(cudaDevAttrMaxThreadsPerBlock) / 2;

                        hyset::timer::device::EventPair* filterTime =  timer->add("Filter", 0);
                        // call prefix filter
                        cuda::launch(hyset::algorithms::device::fgssjoin::prefix_filter<jaccard>,
                                     cuda::launch_configuration_t(gridX, threadsX, cuda::no_shared_memory),
                                     collection, collection, *index, *first, *second, filter->ptr.get(), blockSize, threshold
                        );
                        timer->finish(filterTime);

                        hyset::timer::device::EventPair* verifyTime =  timer->add("Verify", 0);
                        // verify pairs
                        if (aggregate) {
                            cuda::launch(hyset::verification::device::verify_pairs<jaccard, true, false>,
                                         cuda::launch_configuration_t(gridX, threadsX, gridX * sizeof(unsigned int)),
                                         collection, collection, *counts, *first, *second, filter->ptr.get(), blockSize, count.get(), threshold
                            );

                            thrust::device_ptr<unsigned int> thrustCount(counts->output->ptr.get());
                            unsigned long result = thrust::reduce(thrust::device, thrustCount, thrustCount + gridX);
                            auto* countHandler = (hyset::output::count_handler*) output.get();
                            countHandler->count += result;

                        } else {
                            cuda::launch(hyset::verification::device::verify_pairs<jaccard, false, false>,
                                         cuda::launch_configuration_t(gridX, threadsX, cuda::no_shared_memory),
                                         collection, collection, *pairs, *first, *second, filter->ptr.get(), blockSize, count.get(), threshold
                            );

                            // copy counter to main memory
                            std::unique_ptr<unsigned int> globalCount = std::unique_ptr<unsigned int>(new unsigned int);
                            cuda::memory::copy(globalCount.get(), count.get(), sizeof(unsigned int));

                            auto* pairsHandler = (hyset::output::pairs_handler*) output.get();
                            std::vector<hyset::structs::pair> tmp;
                            tmp.resize(*globalCount);
                            cuda::memory::copy(&tmp[0], pairs->output->ptr.get(), sizeof(hyset::structs::pair) * (*globalCount));
                            pairsHandler->pairs.insert(std::end(pairsHandler->pairs), std::begin(tmp), std::end(tmp));
                            cuda::memory::zero(count.get(), sizeof(unsigned int));
                        }
                        timer->finish(verifyTime);

                        hyset::timer::device::EventPair* emptyFilter =  timer->add("Clear filter space", 0);
                        // empty device memory for next join
                        cuda::memory::zero(filter->ptr.get(), sizeof(unsigned int) * filter->length);
                        timer->finish(emptyFilter);
                    }



                    inline void join(hyset::structs::partition* first, hyset::structs::partition* second) {
                        // first apply length filter on block level
                        filtered_map joins = hyset::algorithms::device::length_filter<jaccard>(first, second, hostCollection, threshold);
                        filtered_map::iterator leftIterator = joins.begin();
                        while (leftIterator != joins.end()) { // process each join
                            hyset::structs::block* left = leftIterator->first;
                            std::vector<hyset::structs::block*>::iterator rightIterator;

                            hyset::index::make_inverted_index(*index, *left, hostCollection);
                            for (rightIterator = leftIterator->second.begin(); rightIterator != leftIterator->second.end(); ++rightIterator) {
                                join(left, *rightIterator);
                            }

                            leftIterator++;
                        }

                    }

                    ~handler() {
                        hyset::timer::device::EventPair* freeTime =  timer->add("Free memory", 0);
                        index->hyset::index::device_index::~device_index();
                        filter->hyset::containers::device_array<unsigned int>::~device_array();
                        if (aggregate) {
                            counts->hyset::containers::device_result<unsigned int>::~device_result();
                        } else {
                            pairs->hyset::containers::device_result<hyset::structs::pair>::~device_result();
                        }
                        timer->finish(freeTime);
                    }

                };
            }

        }
    }
}



#endif // HYSET_HYBRID_ALGORITHMS_HPP